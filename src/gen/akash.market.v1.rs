// This file is @generated by prost-build.
/// BidID stores owner and all other seq numbers.
/// A successful bid becomes a Lease(ID).
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BidId {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
    /// Gseq (group sequence number) is a unique numeric identifier for the group.
    /// It is used to differentiate groups created by the same owner in a deployment.
    #[prost(uint32, tag = "3")]
    pub gseq: u32,
    /// Oseq (order sequence) distinguishes multiple orders associated with a single deployment.
    /// Oseq is incremented when a lease associated with an existing deployment is closed, and a new order is generated.
    #[prost(uint32, tag = "4")]
    pub oseq: u32,
    /// Provider is the account bech32 address of the provider making the bid.
    /// It is a string representing a valid account bech32 address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "5")]
    pub provider: ::prost::alloc::string::String,
    /// BSeq (bid sequence) distinguishes multiple bids associated with a single deployment from same provider.
    #[prost(uint32, tag = "6")]
    pub bseq: u32,
}
impl ::prost::Name for BidId {
    const NAME: &'static str = "BidID";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.BidID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.BidID".into()
    }
}
/// OrderId stores owner and all other seq numbers.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OrderId {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
    /// Gseq (group sequence number) is a unique numeric identifier for the group.
    /// It is used to differentiate groups created by the same owner in a deployment.
    #[prost(uint32, tag = "3")]
    pub gseq: u32,
    /// Oseq (order sequence) distinguishes multiple orders associated with a single deployment.
    /// Oseq is incremented when a lease associated with an existing deployment is closed, and a new order is generated.
    #[prost(uint32, tag = "4")]
    pub oseq: u32,
}
impl ::prost::Name for OrderId {
    const NAME: &'static str = "OrderID";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.OrderID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.OrderID".into()
    }
}
/// LeaseClosedReason indicates reason bid was closed
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LeaseClosedReason {
    /// LeaseClosedReasonInvalid represents the default zero value for LeaseClosedReason.
    /// This value indicates an uninitialized or invalid lease closure reason and should not
    /// be used
    LeaseClosedInvalid = 0,
    /// values between 1..9999 indicate owner‑initiated close
    LeaseClosedOwner = 1,
    /// values between 10000..19999 are indicating provider initiated close
    /// lease_closed_reason_unstable lease workloads have been unstable
    Unstable = 10000,
    /// lease_closed_reason_decommission provider is being decommissioned
    Decommission = 10001,
    /// lease_closed_reason_unspecified provider did not specify reason
    Unspecified = 10002,
    /// lease_closed_reason_manifest_timeout provider closed leases due to manifest not received
    ManifestTimeout = 10003,
    /// values between 20000..29999 indicate network‑initiated close
    InsufficientFunds = 20000,
}
impl LeaseClosedReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LeaseClosedInvalid => "lease_closed_invalid",
            Self::LeaseClosedOwner => "lease_closed_owner",
            Self::Unstable => "lease_closed_reason_unstable",
            Self::Decommission => "lease_closed_reason_decommission",
            Self::Unspecified => "lease_closed_reason_unspecified",
            Self::ManifestTimeout => "lease_closed_reason_manifest_timeout",
            Self::InsufficientFunds => "lease_closed_reason_insufficient_funds",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "lease_closed_invalid" => Some(Self::LeaseClosedInvalid),
            "lease_closed_owner" => Some(Self::LeaseClosedOwner),
            "lease_closed_reason_unstable" => Some(Self::Unstable),
            "lease_closed_reason_decommission" => Some(Self::Decommission),
            "lease_closed_reason_unspecified" => Some(Self::Unspecified),
            "lease_closed_reason_manifest_timeout" => Some(Self::ManifestTimeout),
            "lease_closed_reason_insufficient_funds" => Some(Self::InsufficientFunds),
            _ => None,
        }
    }
}
/// LeaseID stores bid details of lease.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseId {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
    /// Gseq (group sequence number) is a unique numeric identifier for the group.
    /// It is used to differentiate groups created by the same owner in a deployment.
    #[prost(uint32, tag = "3")]
    pub gseq: u32,
    /// Oseq (order sequence) distinguishes multiple orders associated with a single deployment.
    /// Oseq is incremented when a lease associated with an existing deployment is closed, and a new order is generated.
    #[prost(uint32, tag = "4")]
    pub oseq: u32,
    /// Provider is the account bech32 address of the provider making the bid.
    /// It is a string representing a valid account bech32 address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "5")]
    pub provider: ::prost::alloc::string::String,
    /// BSeq (bid sequence) distinguishes multiple bids associated with a single deployment from same provider.
    #[prost(uint32, tag = "6")]
    pub bseq: u32,
}
impl ::prost::Name for LeaseId {
    const NAME: &'static str = "LeaseID";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.LeaseID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.LeaseID".into()
    }
}
/// Lease stores LeaseID, state of lease and price.
/// The Lease defines the terms under which the provider allocates resources to fulfill
/// the tenant's deployment requirements.
/// Leases are paid from the tenant to the provider through a deposit and withdraw mechanism and are priced in blocks.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Lease {
    /// Id is the unique identifier of the Lease.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<LeaseId>,
    /// State represents the state of the Lease.
    #[prost(enumeration = "lease::State", tag = "2")]
    pub state: i32,
    /// Price holds the settled price for the Lease.
    #[prost(message, optional, tag = "3")]
    pub price: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// CreatedAt is the block height at which the Lease was created.
    #[prost(int64, tag = "4")]
    pub created_at: i64,
    /// ClosedOn is the block height at which the Lease was closed.
    #[prost(int64, tag = "5")]
    pub closed_on: i64,
    #[prost(enumeration = "LeaseClosedReason", tag = "6")]
    pub reason: i32,
}
/// Nested message and enum types in `Lease`.
pub mod lease {
    /// State is an enum which refers to state of lease.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Prefix should start with 0 in enum. So declaring dummy state.
        Invalid = 0,
        /// LeaseActive denotes state for lease active.
        Active = 1,
        /// LeaseInsufficientFunds denotes state for lease insufficient_funds.
        InsufficientFunds = 2,
        /// LeaseClosed denotes state for lease closed.
        Closed = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "invalid",
                Self::Active => "active",
                Self::InsufficientFunds => "insufficient_funds",
                Self::Closed => "closed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "invalid" => Some(Self::Invalid),
                "active" => Some(Self::Active),
                "insufficient_funds" => Some(Self::InsufficientFunds),
                "closed" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Lease {
    const NAME: &'static str = "Lease";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.Lease".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.Lease".into()
    }
}
/// EventOrderCreated is triggered when an order is created.
/// It contains all the information required to identify an order.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventOrderCreated {
    /// Id is the unique identifier of the Order.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<OrderId>,
}
impl ::prost::Name for EventOrderCreated {
    const NAME: &'static str = "EventOrderCreated";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventOrderCreated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventOrderCreated".into()
    }
}
/// EventOrderClosed is triggered when an order is closed.
/// It contains all the information required to identify an order.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventOrderClosed {
    /// Id is the unique identifier of the Order.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<OrderId>,
}
impl ::prost::Name for EventOrderClosed {
    const NAME: &'static str = "EventOrderClosed";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventOrderClosed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventOrderClosed".into()
    }
}
/// EventBidCreated is triggered when a bid is created.
/// It contains all the information required to identify a bid.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventBidCreated {
    /// Id is the unique identifier of the Bid.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<BidId>,
    /// Price stated on the Bid.
    #[prost(message, optional, tag = "3")]
    pub price: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
}
impl ::prost::Name for EventBidCreated {
    const NAME: &'static str = "EventBidCreated";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventBidCreated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventBidCreated".into()
    }
}
/// EventBidClosed is triggered when a bid is closed.
/// It contains all the information required to identify a bid.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventBidClosed {
    /// Id is the unique identifier of the Bid.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<BidId>,
}
impl ::prost::Name for EventBidClosed {
    const NAME: &'static str = "EventBidClosed";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventBidClosed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventBidClosed".into()
    }
}
/// EventLeaseCreated is triggered when a lease is created.
/// It contains all the information required to identify a lease.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventLeaseCreated {
    /// Id is the unique identifier of the Lease.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<LeaseId>,
    /// Price settled for the lease.
    #[prost(message, optional, tag = "3")]
    pub price: ::core::option::Option<
        super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
}
impl ::prost::Name for EventLeaseCreated {
    const NAME: &'static str = "EventLeaseCreated";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventLeaseCreated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventLeaseCreated".into()
    }
}
/// EventLeaseClosed is triggered when a lease is closed.
/// It contains all the information required to identify a lease.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventLeaseClosed {
    /// Id is the unique identifier of the Lease.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<LeaseId>,
    #[prost(enumeration = "LeaseClosedReason", tag = "2")]
    pub reason: i32,
}
impl ::prost::Name for EventLeaseClosed {
    const NAME: &'static str = "EventLeaseClosed";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.EventLeaseClosed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.EventLeaseClosed".into()
    }
}
/// LeaseFilters defines flags for lease list filtering.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LeaseFilters {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
    /// Gseq (group sequence number) is a unique numeric identifier for the group.
    /// It is used to differentiate groups created by the same owner in a deployment.
    #[prost(uint32, tag = "3")]
    pub gseq: u32,
    /// Oseq (order sequence) distinguishes multiple orders associated with a single deployment.
    /// Oseq is incremented when a lease associated with an existing deployment is closed, and a new order is generated.
    #[prost(uint32, tag = "4")]
    pub oseq: u32,
    /// Provider is the account bech32 address of the provider making the bid.
    /// It is a string representing a valid account bech32 address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "5")]
    pub provider: ::prost::alloc::string::String,
    /// State represents the state of the lease.
    #[prost(string, tag = "6")]
    pub state: ::prost::alloc::string::String,
    /// BSeq (bid sequence) distinguishes multiple bids associated with a single deployment from same provider.
    #[prost(uint32, tag = "7")]
    pub bseq: u32,
}
impl ::prost::Name for LeaseFilters {
    const NAME: &'static str = "LeaseFilters";
    const PACKAGE: &'static str = "akash.market.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.market.v1.LeaseFilters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.market.v1.LeaseFilters".into()
    }
}