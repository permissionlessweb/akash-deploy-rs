// This file is @generated by prost-build.
/// DeploymentID represents a unique identifier for a specific deployment on the network.
/// It is composed of two fields: an owner address and a sequence number (dseq).
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeploymentId {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
}
impl ::prost::Name for DeploymentId {
    const NAME: &'static str = "DeploymentID";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.DeploymentID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.DeploymentID".into()
    }
}
/// Deployment stores deploymentID, state and checksum details.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Deployment {
    /// ID is the unique identifier of the deployment.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<DeploymentId>,
    /// State defines the sate of the deployment.
    /// A deployment can be either active or inactive.
    #[prost(enumeration = "deployment::State", tag = "2")]
    pub state: i32,
    /// Hash is an hashed representation of the deployment.
    #[prost(bytes = "vec", tag = "3")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// CreatedAt indicates when the deployment was created as a block height value.
    #[prost(int64, tag = "4")]
    pub created_at: i64,
}
/// Nested message and enum types in `Deployment`.
pub mod deployment {
    /// State is an enum which refers to state of deployment.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        /// Prefix should start with 0 in enum. So declaring dummy state.
        Invalid = 0,
        /// DeploymentActive denotes state for deployment active.
        Active = 1,
        /// DeploymentClosed denotes state for deployment closed.
        Closed = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Invalid => "invalid",
                Self::Active => "active",
                Self::Closed => "closed",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "invalid" => Some(Self::Invalid),
                "active" => Some(Self::Active),
                "closed" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Deployment {
    const NAME: &'static str = "Deployment";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.Deployment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.Deployment".into()
    }
}
/// GroupID uniquely identifies a group within a deployment on the network.
/// A group represents a specific collection of resources or configurations
/// within a deployment.
/// It stores owner, deployment sequence number (dseq) and group sequence number (gseq).
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GroupId {
    /// Owner is the account address of the user who owns the group.
    /// It is a string representing a valid account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Dseq (deployment sequence number) is a unique numeric identifier for the deployment.
    /// It is used to differentiate deployments created by the same owner.
    #[prost(uint64, tag = "2")]
    pub dseq: u64,
    /// Gseq (group sequence number) is a unique numeric identifier for the group.
    /// It is used to differentiate groups created by the same owner in a deployment.
    #[prost(uint32, tag = "3")]
    pub gseq: u32,
}
impl ::prost::Name for GroupId {
    const NAME: &'static str = "GroupID";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.GroupID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.GroupID".into()
    }
}
/// EventDeploymentCreated event is triggered when deployment is created on chain.
/// It contains all the information required to identify a deployment.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventDeploymentCreated {
    /// ID is the unique identifier of the deployment.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<DeploymentId>,
    /// Hash is an hashed representation of the deployment.
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for EventDeploymentCreated {
    const NAME: &'static str = "EventDeploymentCreated";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventDeploymentCreated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventDeploymentCreated".into()
    }
}
/// EventDeploymentUpdated is triggered when deployment is updated on chain.
/// It contains all the information required to identify a deployment.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventDeploymentUpdated {
    /// ID is the unique identifier of the deployment.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<DeploymentId>,
    /// Hash is an hashed representation of the deployment.
    #[prost(bytes = "vec", tag = "2")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for EventDeploymentUpdated {
    const NAME: &'static str = "EventDeploymentUpdated";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventDeploymentUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventDeploymentUpdated".into()
    }
}
/// EventDeploymentClosed is triggered when deployment is closed on chain.
/// It contains all the information required to identify a deployment.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventDeploymentClosed {
    /// ID is the unique identifier of the deployment.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<DeploymentId>,
}
impl ::prost::Name for EventDeploymentClosed {
    const NAME: &'static str = "EventDeploymentClosed";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventDeploymentClosed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventDeploymentClosed".into()
    }
}
/// EventGroupStarted is triggered when deployment group is started.
/// It contains all the information required to identify a group.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventGroupStarted {
    /// ID is the unique identifier of the group.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<GroupId>,
}
impl ::prost::Name for EventGroupStarted {
    const NAME: &'static str = "EventGroupStarted";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventGroupStarted".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventGroupStarted".into()
    }
}
/// EventGroupPaused is triggered when deployment group is paused.
/// It contains all the information required to identify a group.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventGroupPaused {
    /// ID is the unique identifier of the group.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<GroupId>,
}
impl ::prost::Name for EventGroupPaused {
    const NAME: &'static str = "EventGroupPaused";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventGroupPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventGroupPaused".into()
    }
}
/// EventGroupClosed is triggered when deployment group is closed.
/// It contains all the information required to identify a group.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EventGroupClosed {
    /// ID is the unique identifier of the group.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<GroupId>,
}
impl ::prost::Name for EventGroupClosed {
    const NAME: &'static str = "EventGroupClosed";
    const PACKAGE: &'static str = "akash.deployment.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.deployment.v1.EventGroupClosed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.deployment.v1.EventGroupClosed".into()
    }
}