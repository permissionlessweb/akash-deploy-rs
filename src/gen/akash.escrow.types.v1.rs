// This file is @generated by prost-build.
/// Balance holds the unspent coin received from all deposits with same denom
/// DecCoin is not being used here as it does not support negative values,
/// and balance may go negative if account is overdrawn.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Balance {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for Balance {
    const NAME: &'static str = "Balance";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.Balance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.Balance".into()
    }
}
/// Depositor stores state of a deposit.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Depositor {
    /// Owner is the bech32 address of the depositor.
    /// It is a string representing a valid account address.
    ///
    /// Example:
    /// "akash1..."
    /// If depositor is same as the owner, then any incoming coins are added to the Balance.
    /// If depositor isn't same as the owner, then any incoming coins are added to the Funds.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// Height blockchain height at which deposit was created
    #[prost(int64, tag = "2")]
    pub height: i64,
    /// Source indicated origination of the funds
    #[prost(enumeration = "super::super::super::base::deposit::v1::Source", tag = "3")]
    pub source: i32,
    /// Balance amount of funds available to spend in this deposit.
    #[prost(message, optional, tag = "4")]
    pub balance: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// direct indicates if deposited currency should be swapped to ACT (false) at time of the deposit
    #[prost(bool, tag = "5")]
    pub direct: bool,
}
impl ::prost::Name for Depositor {
    const NAME: &'static str = "Depositor";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.Depositor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.Depositor".into()
    }
}
/// State stores state for an escrow account.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum State {
    /// AccountStateInvalid is an invalid state.
    Invalid = 0,
    /// StateOpen is the state when an object is open.
    Open = 1,
    /// StateClosed is the state when an object is closed.
    Closed = 2,
    /// StateOverdrawn is the state when an object are overdrawn.
    Overdrawn = 3,
}
impl State {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "invalid",
            Self::Open => "open",
            Self::Closed => "closed",
            Self::Overdrawn => "overdrawn",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "invalid" => Some(Self::Invalid),
            "open" => Some(Self::Open),
            "closed" => Some(Self::Closed),
            "overdrawn" => Some(Self::Overdrawn),
            _ => None,
        }
    }
}
/// Account stores state for an escrow account.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountState {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// State represents the current state of an Account.
    #[prost(enumeration = "State", tag = "2")]
    pub state: i32,
    /// Transferred total coins spent by this account.
    #[prost(message, repeated, tag = "3")]
    pub transferred: ::prost::alloc::vec::Vec<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// SettledAt represents the block height at which this account was last settled.
    #[prost(int64, tag = "4")]
    pub settled_at: i64,
    /// Funds holds the unspent coins received from all deposits
    #[prost(message, repeated, tag = "5")]
    pub funds: ::prost::alloc::vec::Vec<Balance>,
    #[prost(message, repeated, tag = "6")]
    pub deposits: ::prost::alloc::vec::Vec<Depositor>,
}
impl ::prost::Name for AccountState {
    const NAME: &'static str = "AccountState";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.AccountState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.AccountState".into()
    }
}
/// Account
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::id::v1::Account>,
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<AccountState>,
}
impl ::prost::Name for Account {
    const NAME: &'static str = "Account";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.Account".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.Account".into()
    }
}
/// Payment stores state for a payment.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PaymentState {
    /// Owner is the account bech32 address of the user who owns the deployment.
    /// It is a string representing a valid bech32 account address.
    ///
    /// Example:
    /// "akash1..."
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// State represents the state of the Payment.
    #[prost(enumeration = "State", tag = "2")]
    pub state: i32,
    /// Rate holds the rate of the Payment.
    #[prost(message, optional, tag = "3")]
    pub rate: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// Balance is the current available coins.
    #[prost(message, optional, tag = "4")]
    pub balance: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// Unsettled is the amount needed to settle payment if account is overdrawn
    #[prost(message, optional, tag = "5")]
    pub unsettled: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::DecCoin,
    >,
    /// Withdrawn corresponds to the amount of coins withdrawn by the Payment.
    #[prost(message, optional, tag = "6")]
    pub withdrawn: ::core::option::Option<
        super::super::super::super::cosmos::base::v1beta1::Coin,
    >,
}
impl ::prost::Name for PaymentState {
    const NAME: &'static str = "PaymentState";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.PaymentState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.PaymentState".into()
    }
}
/// Payment
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Payment {
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<super::super::id::v1::Payment>,
    #[prost(message, optional, tag = "2")]
    pub state: ::core::option::Option<PaymentState>,
}
impl ::prost::Name for Payment {
    const NAME: &'static str = "Payment";
    const PACKAGE: &'static str = "akash.escrow.types.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "akash.escrow.types.v1.Payment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/akash.escrow.types.v1.Payment".into()
    }
}